# How Let's eSign Enclave works

Inside Let's eSign Enclave there are 2 [daemons](https://github.com/letsesign/letsesign-enclave/tree/master/enclave/server): a traffic forwarder and a [TEE](https://en.wikipedia.org/wiki/Trusted_execution_environment) server. The traffic forwarder simply forwards network traffic via the [secure local channel](https://nitro-enclaves.workshop.aws/en/my-first-enclave/secure-local-channel.html), and the TEE server is in charge of (a) fetching the computing jobs from the external server and (b) reporting the results of the executions of the computing jobs back to the external server (all through the traffic forwarder).

There are 3 types of computing jobs, and each corresponds to a [function](https://github.com/letsesign/letsesign-enclave/tree/master/enclave/server/functions) to be executed by the TEE server. The functions are explained below:
1. **send_request()**: This function is responsible for
    - decrypting the encrypted document submitted by the signature requestor (aka sender) using an AWS KMS key that is only accessible to the Nitro Enclaves instances that implement Let's eSign Enclave;
    - sending the signing request to a signer via email, which contains an eSign button that encapsulates a link with some *secret* that can represent the signer's intent to sign the document attached to the email;
    - outputting (a) Proof of Request (**PoR**), which contains the hash of the secret, and (b) the corresponding [attestation document](https://docs.aws.amazon.com/enclaves/latest/user/set-up-attestation.html) (**AR<sub>PoR</sub>**), which can be used to prove the **PoR** is indeed an output of Let's eSign Enclave.
5. **confirm_intent()**: This function takes as inputs **PoR**, **AR<sub>PoR</sub>** and the aforementioned secret, and outputs Proof of Intent (**PoI**) and the corresponding attestation document (**AR<sub>PoI</sub>**) if the input secret matches the hash of the secret within **PoR**.
6. **attach_esignature()**: This function takes as inputs **PoI**, **AR<sub>PoI</sub>** and the encrypted document, and outputs the Final Result (**FR**) and the corresponding attestation document (**AR<sub>FR</sub>**). **FR** contains (a) the final PDF document with eSignatures attached and (b) the corresponding **summary** that gives the details of the signers, the signing dates and most importantly a randomly-generated **Magic Number** that can be used to *visually* identify legitimate eSignatures. As malicious senders cannot know (or guess) the **Magic Number** a priori, they cannot fake eSignatures. Moreover, this function is responsible for sending the final PDF document and the so-called *signing proof* to the sender. The signing proof simply consists of **summary** and **AR<sub>FR</sub>**.
